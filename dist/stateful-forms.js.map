{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/lib/directives/directives-manager.js","src/lib/directives/directives.js","src/lib/expressions/ast.js","src/lib/expressions/lexer.js","src/lib/expressions/parser.js","src/lib/form-elements/stateful-checkbox.js","src/lib/form-elements/stateful-form-element.js","src/lib/form-elements/stateful-radio-group.js","src/lib/form-elements/stateful-radio.js","src/lib/form-elements/stateful-select.js","src/lib/form-elements/stateful-text-input.js","src/lib/stateful-form.js","src/lib/stateful-object.js","src/lib/utils.js","src/polyfills/object-create.js","src/stateful-forms.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"stateful-forms.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var Directives = require('./directives');\n\nfunction DirectivesManager (el) {\n  this.el = el;\n  this.directives = {};\n  this.patchIndex = {};\n\n  this.queryMap(Directives.ShowDirective);\n  this.queryMap(Directives.TextDirective);\n  this.queryMap(Directives.ClassDirective);\n  this.queryMap(Directives.AttributesDirective);\n}\n\nvar Proto = DirectivesManager.prototype;\n\nProto.queryMap = function (cls) {\n  var attr = cls.prototype.attribute;\n  Array.prototype.forEach.call(\n    this.el.querySelectorAll('[' + attr + ']'), function (el) {\n      var directive = new cls(el);\n\n      this.directives[attr] = this.directives[attr] || [];\n      this.directives[attr].push(directive);\n\n      directive.getNames().forEach(function (name) {\n        this.patchIndex[name] = this.patchIndex[name] || [];\n        this.patchIndex[name].push(directive);\n      }.bind(this));\n    }.bind(this));\n};\n\nProto.patch = function (key, state) {\n  // console.log('patch', key, state);\n  if (this.patchIndex.hasOwnProperty(key)) {\n    this.patchIndex[key].forEach(function (directive) {\n      directive.update(state);\n    });\n  }\n};\n\nProto.update = function (state) {\n  // console.log('update', this.directives);\n  Object.keys(this.directives).forEach(function (key) {\n    this.directives[key].forEach(function (directive) {\n      directive.update(state);\n    });\n  }.bind(this));\n};\n\nmodule.exports = DirectivesManager;\n","var Parser = require('../expressions/parser').Parser;\nvar utils = require('../utils');\n\n// Use one parser across directives to make use of the cache\nvar parser = new Parser();\nparser.parse = parser.parse.bind(parser);\nparser.parseObject = parser.parseObject.bind(parser);\n\nfunction Directive (el) {\n  this.el = el;\n  this.attributeValue = this.el.getAttribute(this.attribute);\n  this.expression = this.parse(this.attributeValue);\n\n  /**\n   * @return {Array[String]} names of access members\n   */\n  this.getNames = function () {\n    return this.expression.accessScopeNames;\n  }\n}\n\nfunction ObjectDirective () {\n  this.parse = parser.parseObject;\n  Directive.apply(this, arguments);\n\n  this.update = function (state) {\n    var matchedObject = this.expression.eval(state);\n\n    Object.keys(matchedObject).forEach(function (key) {\n      this.toggleMethod(this.el, key, matchedObject[key]);\n    }.bind(this));\n  };\n}\n\nfunction AttributesDirective () {\n  this.toggleMethod = utils.toggleAttribute;\n  ObjectDirective.apply(this, arguments);\n}\nAttributesDirective.prototype.attribute = 'sf-attributes';\n\nfunction ClassDirective () {\n  this.toggleMethod = utis.toggleClass;\n  ObjectDirective.apply(this, arguments);\n}\nObjectDirective.prototype.attribute = 'sf-class';\n\nfunction ShowDirective () {\n  this.parse = parser.parse;\n  Directive.apply(this, arguments);\n\n  this.update = function (state) {\n    if (!!this.expression.eval(state)) {\n      this.el.style.display = '';\n    } else {\n      this.el.style.display = 'none';\n    }\n  };\n}\nShowDirective.prototype.attribute = 'sf-show';\n\nfunction TextDirective () {\n  this.parse = parser.parse;\n  Directive.apply(this, arguments);\n\n  this.update = function (state) {\n    this.el.innerHTML = this.expression.eval(state);\n  }\n}\nTextDirective.prototype.attribute = 'sf-text';\n\nmodule.exports = {\n  Directive: Directive,\n  ObjectDirective: ObjectDirective,\n  AttributesDirective: AttributesDirective,\n  ClassDirective: ClassDirective,\n  ShowDirective: ShowDirective,\n  TextDirective: TextDirective,\n};\n","/**\n * @param {String} operation\n * @param {Expression} leftExp\n * @param {Expression} rightExp\n */\nfunction Binary (operation, leftExp, rightExp) {\n  this.eval = function (scope) {\n    var left = leftExp.eval(scope);\n\n    switch (operation) {\n      case '&&': return !!left && !!rightExp.eval(scope);\n      case '||': return !!left || !!rightExp.eval(scope);\n    }\n\n    var right = rightExp.eval(scope);\n\n    // Null check for the operations.\n    if (left == null || right == null) {\n      switch (operation) {\n        case '+':\n          if (left != null) return left;\n          if (right != null) return right;\n          return 0;\n        case '-':\n          if (left != null) return left;\n          if (right != null) return 0 - right;\n          return 0;\n      }\n\n      return null;\n    }\n\n    switch (operation) {\n      case '+'  : return autoConvertAdd(left, right);\n      case '-'  : return left - right;\n      case '*'  : return left * right;\n      case '/'  : return left / right;\n      case '~/' : return Math.floor(left / right);\n      case '%'  : return left % right;\n      case '==' : return left == right;\n      case '!=' : return left != right;\n      case '<'  : return left < right;\n      case '>'  : return left > right;\n      case '<=' : return left <= right;\n      case '>=' : return left >= right;\n      case '^'  : return left ^ right;\n      case '&'  : return left & right;\n    }\n\n    throw new Error('Internal error [' + operation + '] not handled');\n  };\n}\n\n/**\n * @param {Expression} object\n * @param {String} name\n */\nfunction AccessMember (object, name) {\n  this.eval = function (scope) {\n    var instance = object.eval(scope);\n    return instance == null ? null : instance[name];\n  };\n}\n\n/**\n * @param {String} name\n */\nfunction AccessScope (name) {\n  this.eval = function (scope) {\n    return scope[name];\n  };\n}\n\n/**\n * @param {String} operation\n * @param {Expression} expression\n */\nfunction PrefixNot (operation, expression) {\n  this.eval = function (scope) {\n    return !expression.eval(scope);\n  };\n}\n\nfunction LiteralPrimitive (value) {\n  this.eval = function (scope) {\n    return value;\n  };\n}\n\n/**\n * @param {Expression} condition\n * @param {Expression} yes\n * @param {Expresssion} no\n */\nfunction Conditional (condition, yes, no) {\n  this.eval = function (scope) {\n    return (!!condition.eval(scope)) ? yes.eval(scope) : no.eval(scope);\n  };\n}\n\n// Add the two arguments with automatic type conversion.\nfunction autoConvertAdd(a, b) {\n  if (a != null && b != null) {\n    if (typeof a == 'string' && typeof b != 'string') {\n      return a + b.toString();\n    }\n\n    if (typeof a != 'string' && typeof b == 'string') {\n      return a.toString() + b;\n    }\n\n    return a + b;\n  }\n\n  if (a != null) {\n    return a;\n  }\n\n  if (b != null) {\n    return b;\n  }\n\n  return 0;\n}\n\nmodule.exports = {\n  Binary: Binary,\n  Conditional: Conditional,\n  AccessMember: AccessMember,\n  AccessScope: AccessScope,\n  PrefixNot: PrefixNot,\n  LiteralPrimitive: LiteralPrimitive\n};\n","/**\n * @param {Number} index\n * @param {String} text\n */\nfunction Token (index, text) {\n  this.index = index;\n  this.text = text;\n}\n\nToken.prototype = {\n  withOp: function (op) {\n    this.opKey = op;\n    return this;\n  },\n  withGetterSetter: function (key) {\n    this.key = key;\n    return this;\n  },\n  withValue: function (value) {\n    this.value = value;\n    return this;\n  },\n  toString: function () {\n    return 'Token(' + this.text + ')';\n  }\n};\n\n/**\n * @param {String} text\n * @return {Array} ArrayOfTokens\n */\nfunction lex (text) {\n  var scanner = new Scanner(text);\n  var tokens = [];\n  var token = scanner.scanToken();\n\n  while (token) {\n    tokens.push(token);\n    token = scanner.scanToken();\n  }\n\n  return tokens;\n}\n\n/**\n * @param {String} input\n */\nfunction Scanner (input) {\n  this.input = input;\n  this.length = input.length;\n  this.peek = 0;\n  this.index = -1;\n\n  this.advance();\n}\n\nScanner.prototype = {\n\n  /**\n   * @return {Token}\n   */\n  scanToken: function () {\n      // Skip whitespace.\n    while (this.peek <= $SPACE) {\n      if (++this.index >= this.length) {\n        this.peek = $EOF;\n        return null;\n      } else {\n        this.peek = this.input.charCodeAt(this.index);\n      }\n    }\n\n    // Handle identifiers and numbers.\n    if (isIdentifierStart(this.peek)) {\n      return this.scanIdentifier();\n    }\n\n    if (isDigit(this.peek)) {\n      return this.scanNumber(this.index);\n    }\n\n    var start = this.index;\n\n    switch (this.peek) {\n      case $PERIOD:\n        this.advance();\n        return isDigit(this.peek) ? this.scanNumber(start) : new Token(start, '.');\n      case $LPAREN:\n      case $RPAREN:\n      case $LBRACE:\n      case $RBRACE:\n      case $LBRACKET:\n      case $RBRACKET:\n      case $COMMA:\n      case $COLON:\n      case $SEMICOLON:\n        return this.scanCharacter(start, String.fromCharCode(this.peek));\n      case $SQ:\n      case $DQ:\n        return this.scanString();\n      case $PLUS:\n      case $MINUS:\n      case $STAR:\n      case $SLASH:\n      case $PERCENT:\n      case $CARET:\n      case $QUESTION:\n        return this.scanOperator(start, String.fromCharCode(this.peek));\n      case $LT:\n      case $GT:\n      case $BANG:\n      case $EQ:\n        return this.scanComplexOperator(start, $EQ, String.fromCharCode(this.peek), '=');\n      case $AMPERSAND:\n        return this.scanComplexOperator(start, $AMPERSAND, '&', '&');\n      case $BAR:\n        return this.scanComplexOperator(start, $BAR, '|', '|');\n      case $TILDE:\n        return this.scanComplexOperator(start, $SLASH, '~', '/');\n      case $NBSP:\n        while (isWhitespace(this.peek)){\n          this.advance();\n        }\n\n        return this.scanToken();\n    }\n\n    var character = String.fromCharCode(this.peek);\n    this.error('Unexpected character [' + character + '}]');\n    return null;\n  },\n\n  /**\n   * @param {Number} string\n   * @param {String} text\n   * @return {Token}\n   */\n  scanCharacter: function (start, text) {\n    assert(this.peek == text.charCodeAt(0));\n    this.advance();\n    return new Token(start, text);\n  },\n\n  /**\n   * @param {Number} string\n   * @param {String} text\n   * @return {Token}\n   */\n  scanOperator: function (start, text) {\n    assert(this.peek == text.charCodeAt(0));\n    assert(OPERATORS.indexOf(text) != -1);\n    this.advance();\n    return new Token(start, text).withOp(text);\n  },\n\n  /**\n   * @param {Number} start\n   * @param {Number} code\n   * @param {String} one\n   * @param {String} two\n   * @return {Token}\n   */\n  scanComplexOperator: function (start, code, one, two) {\n    assert(this.peek == one.charCodeAt(0));\n    this.advance();\n\n    var text = one;\n\n    if (this.peek == code) {\n      this.advance();\n      text += two;\n    }\n\n    assert(OPERATORS.indexOf(text) != -1);\n\n    return new Token(start, text).withOp(text);\n  },\n\n  /**\n   * @return {Token}\n   */\n  scanIdentifier: function () {\n    var start = this.index;\n\n    this.advance();\n\n    while (isIdentifierPart(this.peek)) {\n      this.advance();\n    }\n\n    var text = this.input.substring(start, this.index);\n    var result = new Token(start, text);\n\n    // TODO(kasperl): Deal with null, undefined, true, and false in\n    // a cleaner and faster way.\n    if (OPERATORS.indexOf(text) != -1) {\n      result.withOp(text);\n    } else {\n      result.withGetterSetter(text);\n    }\n\n    return result;\n  },\n\n  /**\n   * @param {String} start\n   * @return {Token}\n   */\n  scanNumber: function (start) {\n    var simple = (this.index == start);\n    this.advance();  // Skip initial digit.\n\n    while (true) {\n      if (isDigit(this.peek)) {\n        // Do nothing.\n      } else if (this.peek == $PERIOD) {\n        simple = false;\n      } else if (isExponentStart(this.peek)) {\n        this.advance();\n\n        if (isExponentSign(this.peek)){\n          this.advance();\n        }\n\n        if (!isDigit(this.peek)){\n          this.error('Invalid exponent', -1);\n        }\n\n        simple = false;\n      } else {\n        break;\n      }\n\n      this.advance();\n    }\n\n    var text = this.input.substring(start, this.index);\n    var value = simple ? parseInt(text) : parseFloat(text);\n    return new Token(start, text).withValue(value);\n  },\n\n  /**\n   * @return {Token}\n   */\n  scanString: function () {\n    var start = this.index;\n    var quote = this.peek;\n\n    this.advance();  // Skip initial quote.\n\n    var buffer;\n    var marker = this.index;\n\n    while (this.peek != quote) {\n      if (this.peek == $BACKSLASH) {\n        if (buffer == null) {\n          buffer = [];\n        }\n\n        buffer.push(this.input.substring(marker, this.index));\n        this.advance();\n\n        var unescaped;\n\n        if (this.peek == $u) {\n          // TODO(kasperl): Check bounds? Make sure we have test\n          // coverage for this.\n          var hex = this.input.substring(this.index + 1, this.index + 5);\n\n          if(!/[A-Z0-9]{4}/.test(hex)){\n            this.error('Invalid unicode escape [\\\\u' + hex + ']');\n          }\n\n          unescaped = parseInt(hex, 16);\n\n          for (var i = 0; i < 5; i++) {\n            this.advance();\n          }\n        } else {\n          unescaped = decodeURIComponent(this.peek);\n          this.advance();\n        }\n\n        buffer.push(String.fromCharCode(unescaped));\n        marker = this.index;\n      } else if (this.peek == $EOF) {\n        this.error('Unterminated quote');\n      } else {\n        this.advance();\n      }\n    }\n\n    var last = this.input.substring(marker, this.index);\n    this.advance();  // Skip terminating quote.\n    var text = this.input.substring(start, this.index);\n\n    // Compute the unescaped string value.\n    var unescaped = last;\n\n    if (buffer != null) {\n      buffer.push(last);\n      unescaped = buffer.join('');\n    }\n\n    return new Token(start, text).withValue(unescaped);\n  },\n\n  advance: function () {\n    if (++this.index >= this.length){\n      this.peek = $EOF;\n    } else {\n      this.peek = this.input.charCodeAt(this.index);\n    }\n  },\n\n  /**\n   * @param {String} message\n   * @param {Number} offset\n   */\n  error: function (message, offset) {\n    offset = offset || 0;\n    var position = this.index + offset;\n    throw new Error('Lexer Error: ' + message + ' at column ' + position + ' in expression [' + this.input + ']');\n  }\n};\n\nvar $EOF       = 0;\nvar $TAB       = 9;\nvar $LF        = 10;\nvar $VTAB      = 11;\nvar $FF        = 12;\nvar $CR        = 13;\nvar $SPACE     = 32;\nvar $BANG      = 33;\nvar $DQ        = 34;\nvar $$         = 36;\nvar $PERCENT   = 37;\nvar $AMPERSAND = 38;\nvar $SQ        = 39;\nvar $LPAREN    = 40;\nvar $RPAREN    = 41;\nvar $STAR      = 42;\nvar $PLUS      = 43;\nvar $COMMA     = 44;\nvar $MINUS     = 45;\nvar $PERIOD    = 46;\nvar $SLASH     = 47;\nvar $COLON     = 58;\nvar $SEMICOLON = 59;\nvar $LT        = 60;\nvar $EQ        = 61;\nvar $GT        = 62;\nvar $QUESTION  = 63;\n\nvar $0 = 48;\nvar $9 = 57;\n\nvar $A = 65;\nvar $E = 69;\nvar $Z = 90;\n\nvar $LBRACKET  = 91;\nvar $BACKSLASH = 92;\nvar $RBRACKET  = 93;\nvar $CARET     = 94;\nvar $_         = 95;\n\nvar $a = 97;\nvar $e = 101;\nvar $f = 102;\nvar $n = 110;\nvar $r = 114;\nvar $t = 116;\nvar $u = 117;\nvar $v = 118;\nvar $z = 122;\n\nvar $LBRACE = 123;\nvar $BAR    = 124;\nvar $RBRACE = 125;\nvar $TILDE  = 126;\nvar $NBSP   = 160;\n\nvar OPERATORS = [\n  'undefined',\n  'null',\n  'true',\n  'false',\n  '+',\n  '-',\n  '*',\n  '/',\n  '~/',\n  '%',\n  '^',\n  '=',\n  '==',\n  '!=',\n  '<',\n  '>',\n  '<=',\n  '>=',\n  '&&',\n  '||',\n  '&',\n  '|',\n  '!',\n  '?'\n];\n\nfunction isWhitespace(code) {\n  return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\n}\n\nfunction isIdentifierStart(code) {\n  return ($a <= code && code <= $z)\n      || ($A <= code && code <= $Z)\n      || (code == $_)\n      || (code == $$);\n}\n\nfunction isIdentifierPart(code) {\n  return ($a <= code && code <= $z)\n      || ($A <= code && code <= $Z)\n      || ($0 <= code && code <= $9)\n      || (code == $_)\n      || (code == $$);\n}\n\nfunction isDigit(code) {\n  return ($0 <= code && code <= $9);\n}\n\nfunction isExponentStart(code) {\n  return (code == $e || code == $E);\n}\n\nfunction isExponentSign(code) {\n  return (code == $MINUS || code == $PLUS);\n}\n\nfunction unescape(code) {\n  switch(code) {\n    case $n: return $LF;\n    case $f: return $FF;\n    case $r: return $CR;\n    case $t: return $TAB;\n    case $v: return $VTAB;\n    default: return code;\n  }\n}\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw message || \"Assertion failed\";\n  }\n}\n\nmodule.exports = {\n  Token: Token,\n  lex: lex\n};\n","var Lexer = require('./lexer');\nvar Expressions = require('./ast');\n\nvar Binary = Expressions.Binary;\nvar AccessMember = Expressions.AccessMember;\nvar AccessScope = Expressions.AccessScope;\nvar PrefixNot = Expressions.PrefixNot;\nvar LiteralPrimitive = Expressions.LiteralPrimitive;\nvar Conditional = Expressions.Conditional;\n\nfunction Parser () {\n  this.cache = {};\n}\n\nParser.prototype = {\n  /**\n   * @param {String} input\n   * @return {ParserImplementation}\n   */\n  parse: function (input) {\n    input = input || '';\n\n    if (!this.cache.hasOwnProperty(input)) {\n      this.cache[input] = new ParserImplementation(Lexer, input).parse();\n    }\n\n    return this.cache[input];\n  },\n\n  /**\n   * @param {String} input\n   * @return {Object}\n   */\n  parseObject: function (input) {\n    var obj = {};\n    var accessScopeNames = [];\n\n    // TODO: there are edges cases here when using split\n    input.split(';').forEach(function (exp) {\n      var keySeparatorIndex = exp.indexOf(':');\n      var expression = this.parse(exp.substring(keySeparatorIndex + 1).trim());\n      accessScopeNames = accessScopeNames.concat(expression.accessScopeNames);\n      obj[exp.substring(0, keySeparatorIndex)] = expression;\n    }.bind(this));\n\n    return {\n      input: input,\n      accessScopeNames: accessScopeNames,\n      eval: function (scope) {\n        var returnObj = {};\n\n        Object.keys(obj).forEach(function (key) {\n          returnObj[key] = obj[key].eval(scope);\n        });\n\n        return returnObj;\n      }\n    };\n  }\n}\n\nvar EOF = new Lexer.Token(-1, null);\n\n/**\n * @param {Object} lexer\n * @param {String} input\n */\nfunction ParserImplementation(lexer, input) {\n  this.index = 0;\n  this.input = input;\n  this.accessScopeNames = [];\n  this.tokens = lexer.lex(input);\n}\n\nParserImplementation.prototype = {\n\n  peek: function () {\n    return (this.index < this.tokens.length) ? this.tokens[this.index] : EOF;\n  },\n\n  parse: function () {\n    var expression = this.parseExpression();\n    // expose useful information\n    expression.input = this.input;\n    expression.accessScopeNames = this.accessScopeNames;\n    return expression;\n  },\n\n  parseExpression: function ()  {\n    var result = this.parseConditional();\n\n    while (this.optional(')')) {\n      return result;\n    }\n\n    return result;\n  },\n\n  parseConditional: function () {\n    var start = this.peek().index,\n      result = this.parseLogicalOr();\n\n    if (this.optional('?')) {\n      var yes = this.parseExpression();\n\n      if (!this.optional(':')) {\n        var end = (this.index < this.tokens.length) ? this.peek().index : this.input.length;\n        var expression = this.input.substring(start, end);\n\n        this.error('Conditional expression' + expression + 'requires all 3 expressions');\n      }\n\n      var no = this.parseExpression();\n      result = new Conditional(result, yes, no);\n    }\n\n    return result;\n  },\n\n  parseLogicalOr: function () {\n    var result = this.parseLogicalAnd();\n\n    while (this.optional('||')) {\n      result = new Binary('||', result, this.parseLogicalAnd());\n    }\n\n    return result;\n  },\n\n  parseLogicalAnd: function () {\n    var result = this.parseEquality();\n\n    while (this.optional('&&')) {\n      result = new Binary('&&', result, this.parseEquality());\n    }\n\n    return result;\n  },\n\n  parseEquality: function () {\n    var result = this.parseRelational();\n\n    while (true) {\n      if (this.optional('==')) {\n        result = new Binary('==', result, this.parseRelational());\n      } else if (this.optional('!=')) {\n        result = new Binary('!=', result, this.parseRelational());\n      } else {\n        return result;\n      }\n    }\n  },\n\n  parseRelational: function () {\n    var result = this.parseAdditive();\n\n    while (true) {\n      if (this.optional('<')) {\n        result = new Binary('<', result, this.parseAdditive());\n      } else if (this.optional('>')) {\n        result = new Binary('>', result, this.parseAdditive());\n      } else if (this.optional('<=')) {\n        result = new Binary('<=', result, this.parseAdditive());\n      } else if (this.optional('>=')) {\n        result = new Binary('>=', result, this.parseAdditive());\n      } else {\n        return result;\n      }\n    }\n  },\n\n  parseAdditive: function () {\n    var result = this.parseMultiplicative();\n\n    while (true) {\n      if (this.optional('+')) {\n        result = new Binary('+', result, this.parseMultiplicative());\n      } else if (this.optional('-')) {\n        result = new Binary('-', result, this.parseMultiplicative());\n      } else {\n        return result;\n      }\n    }\n  },\n\n  parseMultiplicative: function () {\n    var result = this.parsePrefix();\n\n    while (true) {\n      if (this.optional('*')) {\n        result = new Binary('*', result, this.parsePrefix());\n      } else if (this.optional('%')) {\n        result = new Binary('%', result, this.parsePrefix());\n      } else if (this.optional('/')) {\n        result = new Binary('/', result, this.parsePrefix());\n      } else if (this.optional('~/')) {\n        result = new Binary('~/', result, this.parsePrefix());\n      } else {\n        return result;\n      }\n    }\n  },\n\n  parsePrefix: function () {\n    if (this.optional('+')) {\n      return this.parsePrefix(); // TODO(kasperl): This is different than the original parser.\n    } else if (this.optional('-')) {\n      return new Binary('-', new LiteralPrimitive(0), this.parsePrefix());\n    } else if (this.optional('!')) {\n      return new PrefixNot('!', this.parsePrefix());\n    } else {\n      return this.parseAccessMember();\n    }\n  },\n\n  parseAccessMember: function () {\n    var result = this.parsePrimary();\n\n    while (true) {\n      if (this.optional('.')) {\n        var name = this.peek().text;\n        this.advance();\n        result = new AccessMember(result, name);\n      } else {\n        return result;\n      }\n    }\n  },\n\n  parsePrimary: function () {\n    if (this.optional('(')) {\n      // TODO\n      var result = this.parseExpression();\n      return result\n    } else if (this.optional('null') || this.optional('undefined')) {\n      return new LiteralPrimitive(null);\n    } else if (this.optional('true')) {\n      return new LiteralPrimitive(true);\n    } else if (this.optional('false')) {\n      return new LiteralPrimitive(false);\n    } else if (this.peek().key != null) {\n      return this.parseAccessScope();\n    } else if (this.peek().value != null) {\n      var value = this.peek().value;\n      this.advance();\n      return new LiteralPrimitive(value);\n    } else if (this.index >= this.tokens.length) {\n      throw new Error('Unexpected end of expression: ' + this.input);\n    } else {\n      this.error('Unexpected token ' + this.peek().text);\n    }\n\n  },\n\n  parseAccessScope: function () {\n    var name = this.peek().key;\n\n    this.advance();\n\n    if (this.accessScopeNames.indexOf(name) === -1) {\n      this.accessScopeNames.push(name);\n    }\n\n    return new AccessScope(name);\n  },\n\n  /**\n   * @param {String} text\n   * @return {Boolean}\n   */\n  optional: function (text) {\n    if (this.peek().text == text) {\n      this.advance();\n      return true;\n    }\n\n    return false;\n  },\n\n  advance: function () {\n    this.index++;\n  },\n\n  error: function (message) {\n    var location = (this.index < this.tokens.length) ?\n      'at column ' + this.tokens[this.index].index + 1 + ' in' :\n      'at the end of the expression';\n\n    throw new Error('Parser Error: ' + message + ' ' + location + ' [' + this.input + ']');\n  }\n\n};\n\n\nmodule.exports = {\n  Parser: Parser,\n  ParserImplementation: ParserImplementation\n};\n","var StatefulFormElement = require('./stateful-form-element');\n\nvar Cls = function StatefulCheckbox () {\n  StatefulFormElement.apply(this, arguments);\n};\n\nvar Proto = Cls.prototype = Object.create(StatefulFormElement.prototype);\n\nProto.bindEvents = function () {\n  this.el.addEventListener('change', this.updateValue.bind(this));\n};\n\nProto.updateValue = function () {\n  this.setState({ value: this.getValue(), pristine: false, touched: true });\n};\n\nProto.isValid = function () {\n  if (this.el.hasAttribute('required')) {\n    return this.el.checked;\n  }\n  return true;\n};\n\nProto.getValue = function () {\n  return this.el.checked;\n};\n\nmodule.exports = Cls;\n","var StatefulObject = require('../stateful-object');\nvar reflectState = require('../utils').reflectState;\n\nfunction StatefulFormElement (el) {\n  this.el = el;\n  this.name = this.el.getAttribute('name');\n  StatefulObject.call(this);\n  this.onStateChange(reflectState.bind(null, this.el));\n  this.bindEvents();\n  this.triggerStateChange();\n}\n\nvar Proto = StatefulFormElement.prototype = Object.create(StatefulObject.prototype);\n\nProto.getDefaultState = function () {\n  var state = {\n    valid: this.isValid(),\n    pristine: true,\n    touched: false,\n    value: this.getValue()\n  };\n\n  return state;\n};\n\nProto.getValue = function () {\n  return this.el.value;\n};\n\nProto.computedState = function (state) {\n  state.valid = this.isValid();\n\n  return Object.assign(state, {\n    invalid: !state.valid,\n    dirty: !state.pristine,\n    untouched: !state.touched\n  });\n};\n\nmodule.exports = StatefulFormElement;\n","var StatefulObject = require('../stateful-object');\n\nvar Cls = function StatefulRadioGroup (name) {\n  this.name = name;\n  this.radios = [];\n  this.required = false;\n  this.handleRadioStateChange = this.handleRadioStateChange.bind(this);\n  StatefulObject.apply(this, arguments);\n};\n\nvar Proto = Cls.prototype = Object.create(StatefulObject.prototype);\n\n/**\n * @param {StatefulRadio} radio\n */\nProto.addRadio = function (radio) {\n  radio.index = this.radios.length;\n  this.required = this.required || radio.el.hasAttribute('required');\n  this.radios.push(radio);\n  radio.onStateChange(this.handleRadioStateChange);\n}\n\nProto.triggerRadiosStateChange = function () {\n  this.radios.forEach(function (radio) {\n    radio.triggerStateChange();\n  });\n};\n\nProto.getDefaultState = function () {\n  // This is actually not so important since all children will be\n  return {\n    pristine: true,\n    valid: false,\n    touched: false\n  };\n};\n\nProto.handleRadioStateChange = function (state, partialState, key, obj) {\n  var isValid = !this.required || (this.state.valid || state.valid);\n  var isPristine = this.state.pristine && state.pristine;\n  var isTouched = this.state.touched || state.touched;\n\n  this.setState({\n    valid: isValid,\n    invalid: !isValid,\n    pristine: isPristine,\n    dirty: !isPristine,\n    touched: isTouched,\n    untouched: !isTouched\n  }, this.name);\n};\n\n\nmodule.exports = Cls;\n","var StatefulFormElement = require('./stateful-form-element');\n\nvar Cls = function StatefulRadio () {\n  StatefulFormElement.apply(this, arguments);\n};\n\nvar Proto = Cls.prototype = Object.create(StatefulFormElement.prototype);\n\nProto.bindEvents = function () {\n  this.el.addEventListener('change', this.updateValue.bind(this));\n};\n\nProto.updateValue = function () {\n  this.setState({ value: this.getValue(), pristine: false, touched: true });\n};\n\nProto.isValid = function () {\n  return this.getValue();\n};\n\nProto.getValue = function () {\n  return this.el.checked;\n};\n\nmodule.exports = Cls;\n","var StatefulFormElement = require('./stateful-form-element');\n\nfunction StatefulSelect () {\n  StatefulFormElement.apply(this, arguments);\n}\n\nvar Proto = StatefulSelect.prototype = Object.create(StatefulFormElement.prototype);\n\nProto.bindEvents = function () {\n  this.el.addEventListener('change', this.updateValue.bind(this));\n};\n\nProto.updateValue = function () {\n  this.setState({ value: this.getValue(), pristine: false, touched: true });\n};\n\nProto.isValid = function () {\n  return !!this.el.value;\n};\n\nmodule.exports = StatefulSelect;\n","var StatefulFormElement = require('./stateful-form-element');\n\nfunction StatefulTextInput () {\n  StatefulFormElement.apply(this, arguments);\n}\n\nvar Proto = StatefulTextInput.prototype = Object.create(StatefulFormElement.prototype);\n\nProto.bindEvents = function () {\n  var updateValue = this.updateValue.bind(this);\n\n  this.el.addEventListener('keyup', updateValue);\n  this.el.addEventListener('change', updateValue);\n\n  this.el.addEventListener('blur', function onBlur () {\n    this.setState({ touched: true });\n  }.bind(this));\n};\n\nProto.updateValue = function () {\n  this.setState({ value: this.getValue(), pristine: false });\n};\n\nProto.computedState = function (state) {\n  state.valid = this.isValid();\n\n  return Object.assign(state, {\n    invalid: !state.valid,\n    dirty: !state.pristine,\n    untouched: !state.touched\n  });\n};\n\nProto.getValidationRules = function () {\n  var rules = [];\n  var required = this.el.hasAttribute('required');\n  var min = this.el.getAttribute('min');\n  var max = this.el.getAttribute('max');\n  var maxlength = this.el.getAttribute('maxlength');\n  var minlength = this.el.getAttribute('minlength');\n  var pattern = this.el.getAttribute('pattern');\n\n  if (required) {\n    rules.push(function required (val) {\n      return val.length > 0;\n    });\n  }\n\n  if (min !== null) {\n    rules.push(function min (val) {\n      return val >= min;\n    });\n  }\n\n  if (max !== null) {\n    rules.push(function max (val) {\n      return val <= max;\n    });\n  }\n\n  if (minlength !== null) {\n    rules.push(function minlength (val) {\n      return val.length >= minlength;\n    });\n  }\n\n  if (maxlength !== null) {\n    rules.push(function maxlength (val) {\n      return val.length <= maxlength;\n    });\n  }\n\n  if (pattern !== null) {\n    rules.push(function pattern (val) {\n      return val.match(new RegExp(pattern));\n    });\n  }\n\n  return rules;\n};\n\nProto.isValid = function () {\n  var val = this.el.value.trim();\n  // Get validation rules is always called to allow changing of properties\n  var rules = this.getValidationRules();\n  var isValid = true;\n\n  if (this.el.getAttribute('type') === 'email') {\n    isValid = (val.indexOf('@') > 0) && val.length > 2;\n  }\n\n  for (var i = 0; i < rules.length; i++) {\n    isValid = rules[i](val) && isValid;\n    if (!isValid) return false;\n  }\n\n  return isValid;\n};\n\nmodule.exports = StatefulTextInput;\n","var StatefulObject = require('./stateful-object');\nvar StatefulTextInput = require('./form-elements/stateful-text-input');\nvar StatefulSelect = require('./form-elements/stateful-select');\nvar StatefulCheckbox = require('./form-elements/stateful-checkbox');\nvar StatefulRadio = require('./form-elements/stateful-radio');\nvar StatefulRadioGroup = require('./form-elements/stateful-radio-group');\n\nfunction StatefulForm (el) {\n  this.el = el;\n  this.handleFormElementStateChange = this.handleFormElementStateChange.bind(this)\n  this.init();\n  StatefulObject.call(this);\n  this.bindEvents();\n}\n\nvar Proto = StatefulForm.prototype = Object.create(StatefulObject.prototype);\n\n/**\n * Handle state changes by form elements\n */\nProto.handleFormElementStateChange = function (state, partialState, key) {\n  var newState = {};\n  newState[key] = state;\n  this.setState(newState, key);\n};\n\nProto.setFormState = function (newState) {\n  this.setState({ $form: Object.assign({}, this.state.$form, newState) }, '$form');\n};\n\nProto.computedState = function (state) {\n  var isValid = true;\n  var isPristine = state.$form.pristine;\n  var isTouched = state.$form.touched;\n\n  Object.keys(state).forEach(function (key) {\n    if (key.indexOf('$') === 0) return;\n\n    var prop = state[key];\n\n    if (isValid && prop.hasOwnProperty('valid')) {\n      isValid = prop.valid;\n    }\n\n    if (isPristine && prop.hasOwnProperty('pristine')) {\n      isPristine = prop.pristine;\n    }\n\n    if (prop.hasOwnProperty('touched')) {\n      isTouched = isTouched || prop.touched;\n    }\n  });\n\n  Object.assign(state.$form, {\n    valid: isValid,\n    pristine: isPristine,\n    touched: isTouched,\n    invalid: !isValid,\n    dirty: !isPristine,\n    untouched: !isTouched\n  });\n\n  return state;\n};\n\nProto.init = function () {\n  this.formElements = [];\n  this.radioGroups = {};\n\n  Array.prototype.forEach.call(this.el.elements, function (field) {\n    var name = field.name;\n    var type = field.type;\n\n    if (!name) return;\n    if (field.nodeName.toLowerCase() == 'fieldset') return;\n    if (type == 'submit') return;\n    if (type == 'reset') return;\n    if (type == 'button') return;\n    if (type == 'file') return;\n\n    var formElement = createStatefulFormElement(field);\n\n    if (formElement instanceof StatefulRadio) {\n      if (this.radioGroups.hasOwnProperty(name)) {\n        this.radioGroups[name].addRadio(formElement);\n      } else {\n        this.radioGroups[name] = new StatefulRadioGroup(name);\n        this.radioGroups[name].addRadio(formElement);\n      }\n    } else if (formElement !== undefined) {\n      this.formElements.push(formElement);\n    }\n  }.bind(this));\n\n  Object.keys(this.radioGroups).forEach(function (name) {\n    this.radioGroups[name].triggerRadiosStateChange();\n    this.formElements.push(this.radioGroups[name]);\n  }.bind(this));\n};\n\nProto.getDefaultState = function () {\n  var state = {};\n  var isValid = true;\n\n  Array.prototype.forEach.call(this.formElements, function (formElement) {\n    formElement.onStateChange(this.handleFormElementStateChange);\n    state[formElement.name] = formElement.state;\n    isValid = formElement.state.valid && isValid;\n  }.bind(this));\n\n  return Object.assign({\n    $form: {\n      submitted: false,\n      pristine: true,\n      valid: isValid\n    }\n  }, state);\n};\n\nProto.bindEvents = function () {\n  this.el.addEventListener('submit', function (e) {\n    e.preventDefault();\n    this.submit();\n  }.bind(this));\n};\n\nfunction serialize (state) {\n  var result = [];\n\n  Object.keys(state).forEach(function (key) {\n    if (key.indexOf('$') === -1) {\n      result.push(encodeURIComponent(key) + '=' + encodeURIComponent(state[key].value));\n    }\n  });\n\n  return result.join('&');\n}\n\nfunction serializeJSON (state) {\n  var obj = {};\n\n  Object.keys(state).forEach(function (key) {\n    if (key.indexOf('$') === -1) {\n      obj[key] = state[key].value;\n    }\n  });\n\n  return JSON.stringify(obj);\n}\n\nProto.submit = function () {\n  var action = this.el.getAttribute('action');\n  var enctype = this.el.getAttribute('enctype') || 'application/x-www-form-urlencoded; charset=UTF-8';\n\n  if (this.state.hasOwnProperty('$response')) {\n    this.setState({ $response: undefined });\n  }\n\n  if (!this.state.$form.submitted) {\n    this.setFormState({ submitted: true });\n  }\n\n  if (this.state.$form.invalid) return;\n\n  this.setState({\n    $request: Object.assign({}, this.state.$request, {\n      pending: true\n    })\n  });\n\n  var request = new XMLHttpRequest();\n  request.open('POST', action, true);\n  request.setRequestHeader('Content-Type', enctype);\n\n  request.onload = function () {\n    if (request.status >= 200 && request.status < 400) {\n\n      var json;\n      try {\n        json = JSON.parse(request.responseText);\n      } catch (e) {\n        json = {};\n      }\n\n      this.setState({\n        $request: {\n          success: true,\n          pending: false,\n          failed: false,\n          error: false,\n          status: request.status\n        },\n        $response: {\n          json: json,\n          text: request.responseText\n        }\n      });\n    } else {\n      this.setState({\n        $request: {\n          pending: false,\n          success: false,\n          failed: true,\n          error: false,\n          status: request.status\n        }\n      });\n    }\n  }.bind(this);\n\n  request.onerror = function () {\n    this.setState({\n      $request: {\n        pending: false,\n        success: false,\n        failed: false,\n        error: true,\n        status: request.status\n      }\n    });\n  };\n\n  if (enctype === 'application/json') {\n    request.send(serializeJSON(this.state));\n  } else {\n    request.send(serialize(this.state));\n  }\n\n};\n\n// Private\n\nfunction createStatefulFormElement (field) {\n  var type = field.getAttribute('sf-element')\n          || field.type\n          || field.nodeName.toLowerCase();\n\n  switch (type) {\n    case 'textarea':\n    case 'password':\n    case 'text':\n    case 'email':\n    case 'phone':\n    case 'tel':\n    case 'hidden':\n      return new StatefulTextInput(field);\n    case 'checkbox': return new StatefulCheckbox(field);\n    case 'radio': return new StatefulRadio(field);\n    case 'select-one':\n    case 'select':\n      return new StatefulSelect(field);\n    default:\n      console.error('Form element type `' + type + '` not supported by Stateful Forms', field);\n  }\n}\n\nmodule.exports = StatefulForm;\n","function StatefulObject () {\n  this.listeners = [];\n  this.setState(this.getDefaultState());\n}\n\nvar Proto = StatefulObject.prototype;\n\nProto.onStateChange = function (listener) {\n  this.listeners.push(listener);\n  return this;\n};\n\nProto.triggerStateChange = function (partialNewState, key) {\n  this.listeners.forEach(function (listener) {\n    listener(this.state, partialNewState, key, this);\n  }.bind(this));\n  return this;\n};\n\n/**\n * @param {Object} partialNewState\n * @param {?String} key\n */\nProto.setState = function (partialNewState, key) {\n  var name = key || this.name;\n  var oldState = this.state || {};\n  this.state = this.computedState(Object.assign({}, this.state, partialNewState));\n  if (JSON.stringify(oldState[key]) !== JSON.stringify(partialNewState)) {\n    this.triggerStateChange(partialNewState, name);\n  }\n  return this;\n};\n\nProto.computedState = function (state) {\n  return state;\n};\n\nProto.getDefaultState = function () {\n  return {};\n};\n\nmodule.exports = StatefulObject;\n","// IE8+\nfunction removeClass (el, className) {\n  if (el.classList) {\n    el.classList.remove(className);\n  } else {\n    el.className = el.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n  }\n}\n\n// IE8+\nfunction addClass (el, className) {\n  if (el.classList) {\n    el.classList.add(className);\n  } else {\n    el.className += ' ' + className;\n  }\n}\n\nfunction toggleClass (el, className, isApplied) {\n  if (isApplied) {\n    addClass(el, className);\n  } else {\n    removeClass(el, className);\n  }\n}\n\nfunction toggleAttribute (el, attrName, isApplied) {\n  if (isApplied) {\n    el.setAttribute(attrName, attrName);\n  } else {\n    el.removeAttribute(attrName);\n  }\n}\n\nfunction reflectState (el, state) {\n  Object.keys(state).forEach(function (key) {\n    if (typeof state[key] === 'boolean') {\n      toggleClass(el, 'is-' + key, !!state[key]);\n    } else if (key === 'value') {\n      toggleClass(el, 'has-value', !!state[key]);\n    }\n  });\n}\n\nmodule.exports = {\n  toggleClass: toggleClass,\n  reflectState: reflectState,\n  removeClass: removeClass,\n  addClass: addClass,\n  toggleAttribute: toggleAttribute\n};\n","// Some browsers do not support Object.create\nif (typeof Object.create === 'undefined') {\n\tObject.create = function(prototype) {\n\t\tfunction C() {}\n\t\tC.prototype = prototype;\n\t\treturn new C();\n\t}\n}\n","'use strict';\n/**\n * Stateful forms\n * ---\n * Author: Jeroen Ransijn\n * License: MIT\n */\nrequire('./polyfills/object-create');\nvar StatefulForm = require('./lib/stateful-form');\nvar DirectivesManager = require('./lib/directives/directives-manager');\n\nglobal.createStatefulForms = function createStatefulForms () {\n  var forms = document.querySelectorAll('form[stateful]');\n\n  // IE9+ NodeList iteration\n  return Array.prototype.map.call(forms, function (form) {\n    var manager = new DirectivesManager(form);\n    return new StatefulForm(form).onStateChange(function (state, partialState, key) {\n      console.log('form:stateChange', key, state);\n      if (key) {\n        manager.patch(key, state);\n      } else {\n        manager.update(state);\n      }\n    }).triggerStateChange();\n  });\n}\n"]}